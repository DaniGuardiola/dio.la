---
date: 2024/6/13
title: The open/closed component
description: A powerful pattern for building extensible UI components that achieve more with less.
topics:
  - design-systems
  - js
  - react
  - frontend
imageUrl: /open-graph/the-open-closed-component-part-1.png
---

import { TheOpenClosedComponentIndex } from "~/components/ArticleSeriesIndex/TheOpenClosedComponentIndex";
import { Blitz } from "~/components/Blitz";

<TheOpenClosedComponentIndex />

There is a pattern that I've come to understand as a **must-have** for many of the UI components I build. I would dare to say it is one of the most powerful ideas I've ever encountered as a front-end developer.

I'm talking about "the **open/closed** component", as coined by [Diego Haz](https://haz.dev/) (author of [Ariakit](https://ariakit.org/)), who introduced this concept in [this Twitter thread](https://twitter.com/diegohaz/status/1305450112890662914).

This pattern has been silently implemented by many for a long time, and thanks to Diego, we now have a name for it. In this series, I'll explain what it is, why it's so powerful, and how to build components that follow this pattern.

> **Note:** this article will use React in examples and explanations, but the pattern applies to most component-oriented frameworks.
>
> Future articles in the series might go over the details of implementing the pattern in other paradigms, like Solid.js or others.

# A Game of Props

## The problem

If you've been in the front-end game for long enough, this situation might be familiar. Consider the following React example:

```jsx
function Button({ variant }) {
  return <button className={variant} />;
}

function App() {
  return (
    <>
      <Button variant="primary" />
      <Button variant="secondary" />
    </>
  );
}
```

This looks fine, just one little problem... The buttons are _useless_! There is no way to pass a click event listener!

To fix this, let's add an `onClick` prop to the `Button` component:

```jsx
function Button({ variant, onClick }) {
  return <button className={variant} onClick={onClick} />;
}
```

That does the trick. Further down the line, you'll inevitably need other `<button />` props, such as `disabled`, `type`, `form`, etc.

Instead of slowly adding them one by one over time as they come up, we can be smarter about it. We can collect the "custom" props like `variant` (through destructuring), and then pass the rest straight down to the `<button />` element:

```jsx
function Button({ variant, ...props }) {
  return <button className={variant} {...props} />;
}
```

It's been pretty straightforward so far, but here's where it starts to get a bit trickier. What happens if you now pass a `className` prop to the `Button` component?

```tsx {4}
function Button({ variant, ...props }) {
  return <button className={variant} {...props} />;
}

<Button variant="primary" className="my-class" />;
```

The `"my-class"` value -passed through `{...props}`- will take precedence over `"primary"` -passed through `className={variant}`.

The resolved value that's passed to the `<button />` element will be `"my-class"`, and `variant="primary"` will have no effect at all!

---

### Prop spreading and precedence

Let's take a quick detour to explain what happens when you pass the same prop (like `className`) multiple times to a component, including as part of prop spreading (e.g. `<div {...props} />`).

If you already understand these concepts, feel free to skip ahead.

> Passing props to a component results in the same behavior as declaring properties in an object.
>
> That's no coincidence: when the JSX source gets compiled into JavaScript, props are compiled into actual objects! Consider this example:
>
> ```jsx
> <div propA="first" propB={123} propA="second" />
> ```
>
> That JSX component will be typically compiled into something like this:
>
> ```jsx
> jsx("div", {
>   propA: "first",
>   propB: 123,
>   propA: "second",
> });
> ```
>
> In both cases, `propA` will be resolved with a value of `"second"`, since it comes last and overrides any previous props/properties with the same key. If we de-duplicate the keys and leave the final values, we get:
>
> ```jsx
> <div propA="second" propB={123} />;
>
> // compiled:
> jsx("div", {
>   propA: "second",
>   propB: 123,
> });
> ```
>
> When spreading, it's no different. The spread syntax for props and properties is simply syntax sugar for passing multiple key-value pairs at once. Consider the following:
>
> ```jsx
> const props = {
>   propA: "second",
>   propC: "abc",
> };
>
> <div propA="first" propB={123} {...props} propC="xyz" />;
>
> // compiled:
> jsx("div", {
>   propA: "first",
>   propB: 123,
>   ...props,
>   propC: "xyz",
> });
> ```
>
> If we "flatten" the spreads into simple props, we get:
>
> ```tsx
> <div propA="first" propB={123} propA="second" propC="abc" propC="xyz" />;
>
> // compiled:
> jsx("div", {
>   propA: "first",
>   propB: 123,
>   propA: "second",
>   propC: "abc",
>   propC: "xyz",
> });
> ```
>
> Which in turn, de-duplicates to:
>
> ```jsx
> <div propA="second" propB={123} propC="xyz" />;
>
> // compiled:
> jsx("div", {
>   propA: "second",
>   propB: 123,
>   propC: "xyz",
> });
> ```

---

Of course, we don't want `variant="primary"` to be ignored, we need our variant class to be set. We could try inverting the order, like this:

```jsx
function Button({ variant, ...props }: ButtonProps) {
  return <button {...props} className={variant} />;
}
```

However, that doesn't fix anything, it simply switches the problem around. Now, the variant class will take precedence, and the incoming `className` prop will be ignored.

## The solution

Since multiple CSS classes can be applied to an element, we can simply merge all values together:

```jsx
function Button({ variant, ...props }) {
  return <button {...props} className={`${variant} ${props.className}`} />;
}
```

Note how we're still passing `className` twice (once through the spread, and once explicitly). This is fine as long as the merged version is last, as it will take precedence.

We can go further, and merge other props as well, like event handlers:

```jsx
function Button({ variant, ...props }) {
  return (
    <button
      {...props}
      className={`${variant} ${props.className}`}
      onClick={(event) => {
        props.onClick?.(event); // <-- external handler
        console.log("internal handler");
      }}
    />
  );
}
```

> Note that these two examples are simplified and incomplete. I go into a lot more detail on these topics in the next part of the series.

This strategy is great, but we can't merge every prop. The amount of props that can be merged is actually rather small: `className`, `style`, `ref`, and event handlers.

While we can't merge non-mergeable props (duh!), we can let external props override the internal ones. With this approach, the values passed internally can be thought of as "defaults" for the underlying element or component. Defaults that the user can override if needed.

# What is an open/closed component?

The approach to handling props outlined in the previous example is a part of building an **open/closed** component.

Here's how [Diego](https://haz.dev/) defined it:

> The open/closed (...) component:
>
> A component that is based on the open/closed principle, which states that "software entities (classes, modules, functions, etc.) should be **open for extension**, but **closed for modification**".

Let's digest this:

- The component is **closed** for modification, meaning that you can't change the component itself. You can't edit its source code to adapt it to your needs!
- The component is **open** for extension, meaning that you can extend it **without** changing its implementation.

This is a critical point to understand. As Diego put it:

> A component is closed for modification when you **don't need** to update its source code to extend its functionality.

It's not just that you **can't** update the source code, it's that you **don't need to**.

## Sprinkles on top

Native HTML elements are great examples of the open/closed principle in action. You can't alter their core functionality, but you can enhance them with attributes and event listeners to suit your needs.

This concept also applies when you develop your components. By designing components that don't obscure the underlying elements, you allow users to access both the native capabilities and any custom features you've added.

For example, if you create a custom button, users can interact with both the button's native functionality (e.g. `onClick`) and any additional features you've designed (e.g. `variant`).

![invert || A diagram representing the idea above with an example of a Button component](button-sprinkles.png)

By following the open/closed principle, more components can be created on top of existing components, forming a hierarchy of components that build on each other.

> If this sounds familiar, that's because it's just good old [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming)! The [open/closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) is an OOP concept.

A way I like to think about this is that you're taking a native element or component, and adding a few sprinkles of functionality (or aesthetics) on top of it.

## When inheritance enables composition

In component-oriented UI frameworks like React and Solid.js, a recommended best practice is to [use composition instead of inheritance](https://legacy.reactjs.org/docs/composition-vs-inheritance.html).

Open/closed components seem to contradict this advice: they inherit and extend the behavior and API of a different element or component. Ironically though, building components this way enables **advanced composition patterns**.

Notably, it enables **the "render as" pattern** (also known by nerds like me as "polymorphism"), which consists of rendering a component as a different element or component. Many UI component libraries support this, though the exact implementation and API varies.

The ([infamous](https://twitter.com/jjenzz/status/1423766700885954562)) `as` prop is probably the most known, and [Radix's `asChild` approach](https://www.radix-ui.com/primitives/docs/guides/composition) is also fairly well-known, but for the following examples, I'll use [the `render` prop from Ariakit](https://ariakit.org/guide/composition).

```jsx
<MyButton render={<a href="https://dio.la/" />} />
```

The example above will render `MyButton` -including its custom styles and behavior- as an `<a>` HTML element (instead of the default `<button>`) that links to my blog. We can also do this with a component:

```jsx
<MyTab render={<Link href="/new" />}>New</Tab>
```

In this case, `MyTab` will be rendered as a `Link` (here, `Link` could be a framework-specific component that handles routing, [e.g. in Next.js](https://nextjs.org/docs/app/api-reference/components/link)).

It's important to understand what we mean by "rendered as", so let's break it down:

- `MyTab` renders a `<button>` element by default. It passes it a few props, like `className` for styling.
- `Link` renders an `<a>` element under the hood, and passes it a few props as well. For example, to handle client-side routing, it passes an `onClick` handler. It also passes the `href` prop down to `<a>`.

![invert || A diagram representing the ideas above](composition-1.png)

When we make `MyTab` "render as" a `Link`, the props that it would pass to `<button>` (like `className`) are now passed to `Link` instead. In this way, a "chain" of components is created where props flow down until they ultimately reach the underlying HTML element.

![invert || A diagram representing the idea above](composition-2.png)

Note how `Link` forwards the `className` prop down to `<a>`. If this wasn't the case, then the `MyTab` component would lose its appearance!

![invert || A diagram representing the idea above](composition-3.png)

This is because `MyTab` has an HTML-element-shaped "hole". By default, that hole is filled with a `<button>`, but it can be filled with anything else that behaves like an HTML element.

How does an HTML element behave then? Among other things, it accepts CSS classes that are reflected in the HTML document tree.

If `className` is ignored by `Link`, then we can't say it behaves like an HTML element. That's why this last example would break!

---

To avoid this kind of problem, Radix has a couple of rules, including ["Your component must spread props"](https://www.radix-ui.com/primitives/docs/guides/composition#your-component-must-spread-props). Similarly, Ariakit indicates that ["Custom components must be open for extension"](https://ariakit.org/guide/composition#custom-components-must-be-open-for-extension), which can be broken down into a few rules including "Spread all props (...)".

In other words, the components **must be open/closed**! These two libraries (as well as many others) have HTML-element-shaped holes everywhere, and all of their components are designed to be open/closed and _fit into those holes_.

This unlocks amazing composition patterns like the following example [from the Radix docs](https://www.radix-ui.com/primitives/docs/guides/composition#composing-multiple-primitives):

```jsx {2-6}
<RadixDialog.Root>
  <RadixTooltip.Root>
    <RadixTooltip.Trigger asChild>
      <RadixDialog.Trigger asChild>
        <MyButton>Open dialog</MyButton>
      </RadixDialog.Trigger>
    </RadixTooltip.Trigger>
    <RadixTooltip.Portal>...</RadixTooltip.Portal>
  </RadixTooltip.Root>

  <RadixDialog.Portal>...</RadixDialog.Portal>
</RadixDialog.Root>
```

Since Ariakit components are open/closed too, we can easily mix and match components from both libraries without any issues!

Below, I've rewritten the example replacing the Radix tooltip and the custom button with Ariakit components.

```jsx {2-8}
<RadixDialog.Root>
  <Ariakit.TooltipProvider>
    <Ariakit.TooltipAnchor
      render={
        <RadixDialog.Trigger asChild>
          <Ariakit.Button>Open dialog</Ariakit.Button>
        </RadixDialog.Trigger>
      }
    />
    <Tooltip.Portal>...</Tooltip.Portal>
  </Ariakit.TooltipProvider>

  <RadixDialog.Portal>...</RadixDialog.Portal>
</RadixDialog.Root>
```

Here's a live demo of Radix and Ariakit working together:

<Blitz blitzId="vitejs-vite-zchpdx" file="src/App.tsx" />

Both Radix and Ariakit are fairly low-level, so they can be a little verbose. In your own component library, with the right abstractions, composition can become even simpler!

This is [a real example](https://atlas.guide.co/?path=/story/stories-menu--trigger-with-tooltip) from a component library I built in the past:

```jsx {1-5}
<Menu.Root>
  <Tooltip content="More options">
    <Menu.Trigger>
      <Button icon={optionsIcon} />
    </Menu.Trigger>
  </Tooltip>
  <Menu.Content>...</Menu.Content>
</Menu.Root>
```

In this snippet, we have a **button** that acts as a **menu trigger** and a **tooltip trigger**. It renders as a single `<button>` element but has the behavior of all three components.

All of this is enabled by open/closed components, along with the "render as" pattern!

## Use the platform

The web is a chaotic and beautiful amalgamation of technologies and APIs. Yes, it may be a _mess_, but it is _our mess_.

It is tempting to try and abstract away the platform, reinvent all of the wheels, and build neat little black boxes so you can forget about what's below. But that dream is not only impossible, it's also a nightmare. The web is too vast and too complex to be tamed.

Things used to be simpler a long time ago, but it's {new Date().getFullYear()} now. These days the web is, for the most part, "batteries included". Here are some of my favorite examples, including a lot of stuff we used to need custom abstractions or hacks for:

- In **HTML**, we got...

  - [Semantics:](https://developer.mozilla.org/en-US/docs/Glossary/semantics#semantic_elements) `<header>`, `<nav>`, `<main>`, `<article>`...
  - [Media](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML5_audio_and_video) and [custom rendering:](<(https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)>) `<video>`, `<audio>`, `<canvas>`.
  - [Lazy loading](https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading) of scripts, fonts, images and iframes.
  - [Responsive images.](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)
  - [Web components.](https://developer.mozilla.org/en-US/docs/Web/Web_Components)
  - [Details and summary.](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details)
  - [Date and time inputs.](https://developer.mozilla.org/en-US/docs/Learn/Forms/HTML5_input_types#date_and_time_pickers)
  - [Color picker input.](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/color)
  - [Popovers!](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/popover)
  - [Dialogs!](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog)

- In **CSS**, we got...

  - [Custom properties (A.K.A. CSS variables).](https://developer.mozilla.org/en-US/docs/Web/CSS/--*)
  - [`:has()`](https://developer.mozilla.org/en-US/docs/Web/CSS/:has), [`:is()`](https://developer.mozilla.org/en-US/docs/Web/CSS/:is), and [`:where()`](https://developer.mozilla.org/en-US/docs/Web/CSS/:where).
  - [Aspect ratio.](https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio)
  - [Cascade layers.](https://developer.mozilla.org/en-US/docs/Web/CSS/Cascade#cascade_layers)
  - [Grid](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout) and [flexbox](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout) layouts.
  - [Logical properties.](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties)
  - [Nesting.](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator)
  - [Container](https://developer.mozilla.org/en-US/docs/Web/CSS/@container) and [style](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_size_and_style_queries) queries.
  - [Viewport units.](https://developer.mozilla.org/en-US/docs/Web/CSS/length#relative_length_units_based_on_viewport)
  - [Scroll snap.](https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-type)
  - [Sticky positioning.](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)
  - [Automatic dark mode.](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme)
  - [Houdini.](https://developer.mozilla.org/en-US/docs/Web/API/Houdini_APIs)
  - Experimental, proposed, or coming soon: [`anchor positioning`](https://developer.chrome.com/blog/anchor-positioning-api), [`scoping`](https://developer.mozilla.org/en-US/docs/Web/CSS/@scope), [stylable select](https://open-ui.org/components/selectlist/), [view transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API)...

- In **JavaScript**, we got...

  - [`const`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const) and [`let`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let).
  - [Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) and [dynamic imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import).
  - [`async` and `await`.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
  - [Destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment), [spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax), and [rest](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) syntax.
  - [Arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining), [nullish coalescing](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator)...
  - [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) and [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect).
  - [Private class properties.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_properties)
  - New array methods: [`map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map), [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter), [`reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)...
  - New data structures: [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set), [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), [WeakSet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet), [WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)...
  - [Symbols.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
  - [Iterators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols), [async iterators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator), and [generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
  - [BigInt.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
  - [Intl.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
  - [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray), [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [DataView](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView), [Atomics](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics)...
  - Experimental, proposed, or coming soon: [pipe operator](https://github.com/tc39/proposal-pipeline-operator), [record and tuple](https://github.com/tc39/proposal-record-tuple), [pattern matching](https://github.com/tc39/proposal-pattern-matching), [Temporal](https://github.com/tc39/proposal-temporal), [decorators](https://github.com/tc39/proposal-decorators), [import attributes](https://github.com/tc39/proposal-import-attributes), [JSON modules](https://github.com/tc39/proposal-import-attributes)...

- We got tons of great [**web APIs**:](https://developer.mozilla.org/en-US/docs/Web/API) `fetch`, `IntersectionObserver`, `ResizeObserver`, `WebSockets`, `WebRTC`, `Web Workers`, `Service Workers`, `IndexedDB`, `Web Storage`, `Web Audio`, `Web Speech`, `Web MIDI`, `WebUSB`, `Web Share`, `WebXR`... The list goes on and on.

- [Progressive web apps](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps) got easier to build.

- [WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly) is now a thing.

This is not to say that you shouldn't build abstractions. You should! But you should build them on top of the platform, not instead of it. At the UI level, this is precisely what open/closed components enable.

---

Most people are familiar with "the 3 R's": reduce, reuse, recycle. What not everyone knows is that these are in order of importance.

In terms of ecological impact, recycling something is great, but it's better to reuse it (e.g. by repairing it). And it's even better if you can find a way to not use it -or use less of it- in the first place (reduce).

With UI components, I believe a similar logic can be applied:

### Reduce

If there's an HTML element that does what you need, use it.

> ❌ DON'T
>
> `<div onClick={action}>`
>
> `<div onClick={() => window.location = "example.com")}>`
>
> ✅ DO
>
> `<button onClick={action}>`
>
> `<a href="example.com">`

Please? Thank you.

### Reuse

If you truly need an abstraction, use a minimal version that can be easily reused and composed in many places.

> ❌ DON'T
>
> Use [moment.js](https://momentjs.com/) - it's big, monolithic, and has a lot of custom implementations of things that are already in the platform these days.
>
> [Read more.](https://momentjs.com/docs/#/-project-status/)
>
> ✅ DO
>
> Use native APIs like [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat), [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date), [`Date.toLocaleString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString), etc + minimal and modular libraries like [`date-fns`](https://date-fns.org/).
>
> [Read more.](https://dockyard.com/blog/2020/02/14/you-probably-don-t-need-moment-js-anymore)

### Recycle

When HTML elements and platform features fall short, or when you simply need styled versions of them, then it's time to build your own components. Choose a base HTML element or UI primitive, extend it with your own styles and behavior, and make sure it's open/closed.

> ❌ DON'T
>
> ```jsx
> <MyButton
>   action={{ on: "click-and-enter", callback: myCallback }}
>   tooltip="My tooltip"
>   tooltipPosition="top"
> >
>   Click me!
> </MyButton>
> // renders a <div>
> ```
>
> Since everything is custom, and we're using a `<div>`, the component needs to implement custom logic to make it focusable, accessible by keyboard, discoverable to screen readers, etc. We also need to implement a tooltip and pass all event listeners internally, as it's the only way.
>
> ✅ DO
>
> ```jsx
> <MyTooltip content="My tooltip" position="top">
>   <MyButton onClick={myCallback}>Click me!</MyButton>
> </MyTooltip>
> // renders a <button>
> ```
>
> Since we're extending a `<button>`, we get all of the native behavior for free. We can also compose it with other components like `MyTooltip`, which uses the "render as" pattern to add tooltip trigger behavior to it.
>
> This is only possible because `<MyButton>` is open/closed, and it can pass props like the required event listeners down to the underlying `<button>` element.

---

Beyond specific use cases, like the "render as" example from the previous section, open/closed components allow you to go about building your websites and web apps in a way that is more in tune with the platform:

- First of all, there's the web. HTML, CSS, and JavaScript. The platform.
- Then, add a little bit of UI framework. React, Solid.js, Svelte, Vue, Angular, or whatever you like. With a pinch of meta-framework (Next.js, Solid Start, Nuxt...).
- Sprinkle some of your own styles on top. Maybe a couple of advanced features here and there. Strong, accessible UI primitives from libraries like Ariakit or Radix. Nicer defaults. Open/closed components. A few libraries to help too.

Compose it all together and you have a recipe for success:

- Reasonable bundle sizes. The web does most of the heavy lifting.
- No need to learn custom APIs for anything HTML elements -or the underlying UI primitives- or web APIs already do.
- It will work forever. The web doesn't break, by design. Your abstractions and libraries might.
- It's fast and performant. The web is optimized. Your abstractions might not be.

## The case for accessibility

Probably one of the most important reasons to use open/closed components is accessibility.

The web is accessible by default. Native HTML elements, including form controls, buttons, links, labels, semantic elements, and more, are all accessible. They work with screen readers, keyboard navigation, and other assistive technologies. Out of the box!

When you build your components on top of the platform, you're building on top of all of this. You're building on top of the accessibility features that are already there.

---

> _'Enough philosophical stuff!'_ you say. _'How do I actually build an open/closed component?'_

Okay, okay. We'll do it in the next article (in React for now).

Stay tuned!
