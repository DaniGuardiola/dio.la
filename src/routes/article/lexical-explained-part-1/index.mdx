---
date: 2021/04/23
title: "Lexical, explained (part 1: nodes)"
description: The first part of a deep dive into Lexical, in which we explore nodes and the node tree.
topics:
  - lexical
---

> **Important note:** to make a clear distinction between static and instance members of classes, the following notation will be used throughout this article:
>
> - Static member: `Class::memberName`
> - Instance member: `Class.memberName`

# What is a node?

In Lexical, like in many other rich text editors and frameworks, the state of an editor at a given time is modeled as a node tree\*. Each node in this tree is called a "Lexical node".

According to the docs, nodes not only "represent the underlying data model for what is stored in the editor" but they are also composed to "form the visual editor view". This means that nodes have multiple roles and responsabilities, from serialization to DOM representation.

In Lexical, nodes are built as JavaScript classes. All of them extend the `LexicalNode` class (directly or indirectly), which implements the core functionality. Every node in an `EditorState` tree is an instance of a node class.

> **\* Note:** technically, an `EditorState` contains a node tree **and** a selection state, but we're focusing on the node tree for this section.

# Base nodes

Lexical has five different base nodes that directly extend `LexicalNode`.

Two of them are internal: `RootNode` and `LineBreakNode`. The other three (`ElementNode`, `TextNode`, and `DecoratorNode`) are exposed from the `lexical` package, and can be extended to create other nodes.

## `RootNode`

All editor state trees have a "root" node, or in other words, a node that is at the top level and is the top-most parent of any other node in the tree.

The root node is [automatically created for you](<(https://github.com/facebook/lexical/blob/7d4c87e28f74d15e724596b34b7f57f61be3af84/packages/lexical/src/LexicalEditorState.ts#L53-L55)>) when a new `EditorState` is created from scratch.

## `LineBreakNode`

A line break node is used to represent line breaks (duh) that exist "inline", between text nodes. Note that this is different from the perceived line breaks that exist between block-level nodes.

For example, we might have some content in our editor that looks like this:

```
Lorem ipsum
dolor sit amet
```

The node tree could be represented as a single paragraph node with a line break in between, like this:

```
root
└── paragraph
    ├── text "Lorem ipsum"
    ├── line-break
    └── text "dolor sit amet"
```

This could be visualized like this in HTML:

```html
<div id="root">
  <p>
    <span>Lorem ipsum</span>
    <br />
    <span>dolor sit amet</span>
  </p>
</div>
```

However, the tree could also just have two separate paragraph nodes, like this:

```
root
├── paragraph
│   └── text "Lorem ipsum"
└── paragraph
    └── text "dolor sit amet"
```

In HTML:

```html
<div id="root">
  <p>Lorem ipsum</p>
  <p>dolor sit amet</p>
</div>
```

Let's unpack this:

- In our first example, we have a linebreak node between two text nodes.
  - This is possible because `LineBreakNode` is an **inline** node.
  - A line break is a similar concept to `\n` in plain text, or `<br />` in HTML.
  - This is often referred to as a "soft break", because it allows you to create a new line without creating a new block-level node (in this case, a paragraph).
  - Most editors, including Lexical-based ones, allow you to create a line break by pressing `shift + enter`.
- In our second example, we have two separate paragraph nodes.
  - We're not explicitly declaring a line break in this case.
  - Instead, the line-break is "implied" by the fact that we have two separate paragraph nodes.
  - This happens because paragraph nodes are **block-level** nodes, so they always occupy their own line.
  - In the case of paragraph nodes, pressing `enter` will create a new paragraph node, potentially splitting the current node into two depending on where the cursor or selection is.

This is an important distinction to make, because it has an impact in the content that is actually presented.

A good example of this is paragraph nodes that have some amount of vertical margin. That margin between block-level nodes is only present when you actually have two distinct nodes, and not when you have a line break between two text nodes.

To illustrate the point, this is how the content might look like if we styled our paragraphs from the second example with a bit of vertical margin:

```
Lorem ipsum

dolor sit amet
```

Compared to the original example, there is a significant visual difference in the perceived space between lines.

> As per the Lexical docs, `LineBreakNode` should **always** be used to represent a line break. You should **never** have `\n` in your text nodes.
>
> This is because `LineBreakNode` has been designed to "work consistently between browsers and operating systems".

## `ElementNode`

The main purpose of element nodes is to be used as parents for other nodes, and they can be block-level or inline.

`ElementNode` is not meant to be used directly -NOTE: verify-. Instead, it is used as a base for other nodes, such as `ParagraphNode` or `LinkNode`. The behavior of an element node can be customized by overriding certain methods in the node class, such as `isInline`, `canBeEmpty`, etc.

## `TextNode`

Text nodes are used to represent text content. They are always inline, and have a few properties specific to text, like format (bold, italic, underline...) or style (inline CSS styles).

Read more about these properties in the [Lexical docs](https://lexical.dev/docs/concepts/nodes#textnode).

## `DecoratorNode`

This is probably the most powerful node in Lexical. It can be used to render an arbitrary view (like a React component) inside the editor.

Decorator nodes, like element nodes, can be block-level or inline. In fact, element and decorator nodes are the only ones that can be block-level, every other node is always inline (except the root node... I guess? -NOTE: clarify-).

# Inline vs. block-level

In this article, I've been mentioning the concepts of "inline" and "block-level" a lot, so let me briefly clarify what they mean.

In HTML, block-level elements are elements that occupy their own line, and inline elements are elements that can be placed between other elements in the same line. Lexical is very similar in this regard.

Note that line breaks (`\n`, `<br />` or `LineBreakNode`) are a litle weird in this sense, because they are technically inline nodes but they create a new line. You can think of this as the exception that confirms the rule.

> MDN has good resources to learn about [block-level](https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements) and [inline](https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements) elements in HTML.

Nodes have to follow some rules depending on this distinction when it comes to which node can be a child or sibling of a different node.

For example, a `<p>` element (paragraph) is a block-level element, and a `<span>` element (text) is an inline element. You can have a few `<span>` elements inside a `<p>` element, but you can't have a `<p>` element inside a `<span>` element\*.

_Why is that?_

Because block-level nodes can contain **inline and block-level** nodes as children, but inline nodes can **only** contain other **inline** nodes.

-NOTE: check if this is the case in Lexical and whether it's an error-

-NOTE: check if there's also a constrain like "inline nodes can only be children of block-level nodes"-

> \* Well, you _can_, but that doesn't mean that you _should_ and it is, in fact, invalid HTML.

# Hierarchy: parents, children, and siblings

A tree is a data structure that represents a hierarchy of nodes. A node can be the "parent" of other nodes, and those nodes are referred to as their "children" or "child nodes".

Note that not all nodes are created equal. In fact, only nodes that extend `ElementNode` (with the exception of `RootNode`) can contain children.

Other nodes like `TextNode` (and nodes that extend it) or `LineBreakNode` can't have children. Nodes extending `DecoratorNode` can't have any children either. These are often referred to as "leaf nodes" (they are at the very end of a _tree_ branch, after all). In fact, you can verify this by looking at the [`$isLeafNode` function](https://github.com/facebook/lexical/blob/7d4c87e28f74d15e724596b34b7f57f61be3af84/packages/lexical/src/LexicalUtils.ts#L206-L210) for yourself.

Finally, "sibling nodes" are simply nodes that share the same parent. They are "siblings" of each other.

# The core node: `LexicalNode`

At this point you should have a good understanding of what nodes are, how they are composed together in the node tree, and what the few base nodes are.

It's time to go deeper, and we're gonna start by learning about `LexicalNode`, which is at the core of all nodes, and implements all of the core features present in all of them.

> `LexicalNode` is not meant to be used directly. Instead, it should always be extended. This doesn't mean that you should extend it yourself to build your nodes though, since Lexical provides higher level base nodes (that already extend `LexicalNode`) for you to extend.

## Internal properties

There are three very important internal properties: `__type`, `__parent`, and `__key`. They are initially set in the constructor:

```ts twoslash {1-3}
  constructor(key?: NodeKey) {
    this.__type = this.constructor.getType();
    this.__parent = null;
    $setNodeKey(this, key);
  }
```

Let's learn about them.

### Type: the node's identity

Every node class has a "type". For example, `TextNode` has the `text` type, `ParagraphNode` has the `paragraph` type, `LineBreakNode` has the `line-break` type, and so on, you get it.

The type of a node is declared by overriding the `LexicalNode::getType()` static method. Internally, instances also have the `LexicalNode.__type` property, and a similar `LexicalNode.getType()` instance method.

In fact, the `LexicalNode.__type` property is automatically assigned in the constructor, from the `LexicalNode::getType()` static method, which means that the static method is the source of truth:

```ts twoslash {1}
  constructor(key?: NodeKey) {
    this.__type = this.constructor.getType();
    this.__parent = null;
    $setNodeKey(this, key);
  }
```

The type of a node never changes.

### Parent

To do...

### Key

To do...

## Writable nodes

One of the most common operations in Lexical editors are node updates. For example, we might want to change the indentation (`ElementNode.__indent`) of an element node.

These node updates are usually -NOTE: usually or always?- part of an editor update (`lexicalEditor.update()`), and can be achieved through "writable" nodes.

Writable nodes can be obtained through the `lexicalNode.getWritable()` method, and they are **mutable**. This means that you can change their properties directly like in the example below, and the changes will be applied as part of the update.

```ts twoslash
const [editor] = getEditor();
declare function getNode(): LexicalNode;
// --cut--
editor.update(() => {
  const node = getNode();
  const writableNode = node.getWritable();
  writableNode.__indent = 2;
});
```

## Internal properties

These are the internal properties of a `LexicalNode` instance, used to track some very important information about the node.

They are initially set in the constructor of the node class:

```ts twoslash {1-3}
  constructor(key?: NodeKey) {
    this.__type = this.constructor.getType();
    this.__parent = null;
    $setNodeKey(this, key);
  }
```

### `__type`

The type of the node (e.g. `"text"` or `"paragraph"`).

### `__key`

The key of the node, like `"text"` or `"paragraph"`. It is set in the constructor:

```ts twoslash {1}
  constructor(key?: NodeKey) {
    this.__type = this.constructor.getType();
    this.__parent = null;
    $setNodeKey(this, key);
  }
```

### `__parent`

To do...

## Static methods

These methods are called on the `LexicalNode` class itself. For example:

```ts twoslash
import { LexicalNode } from 'lexical'
declare const paragraphNode: $createParagraphNode()
// --cut--
LexicalNode.clone(paragraphNode)
```

### `getType`

To do...

### `clone`

To do...

## The constructor

To do...

## Getters and traversers

### `getType`, `getKey`, `getParent` and `getParentOrThrow`

To do...

### `getType`, `getKey`, `getParent` and `getParentOrThrow`

To do...

### `isAttached`

To do...

### `isSelected`, `selectPrevious` and `selectNext`

To do...

## View methods

To do...

## Setters and mutators

To do...
