---
draft: true
date: 1970/1/1
title: The open/closed pattern
description: TODO
---

In this article, I'm going to talk about a pattern for building UI components in frameworks like React or Solid. A pattern that I've come to understand as a **must-have** for almost every single component I build.

I'm talking about the **open/closed** pattern, as named by [Diego Haz](https://twitter.com/diegohaz) (author of [Ariakit](https://ariakit.org/)), who introduced this concept in [this Twitter thread](https://twitter.com/diegohaz/status/1305450112890662914).

Note that developers have been doing some of these things for a long time, but it's great to have a name and some specific guidelines for it.

Let's start with a common example.

# A props situation

## The problem

When building using a component, there is a situation that happens very often. Consider the following React example:

```jsx
function Button({ variant }) {
  return <button className={variant} />;
}

function App() {
  return (
    <>
      <Button variant="primary" />
      <Button variant="secondary" />
    </>
  );
}
```

This looks fine. Just one (kind of important) problem... The buttons are _useless_! There is no way to pass a click event listener!

We could fix it by adding an `onClick` prop to the `Button` component:

```jsx
function Button({ variant, onClick }) {
  return <button className={variant} onClick={onClick} />;
}
```

That works, but further down the line, you'll probably need other `<button />` props, such as `disabled`, `type`, `form`, etc.

It makes sense then to just collect the "custom" props like `variant` (e.g. with destructuring), and pass the rest straight down to the `<button />` element:

```jsx
function Button({ variant, ...props }: ButtonProps) {
  return <button className={variant} {...props} />;
}
```

Makes sense so far, but we're not done. What happens now if you pass a `className` prop to the `Button` component?

It will override `className={variant}` since a prop spread (`{...props}`) behaves like an object spread (or `Object.assign()`), which means that later properties get replaced.

That's not what we want, we need our variant class to be set. We could invert the order, like this:

```jsx
function Button({ variant, ...props }: ButtonProps) {
  return <button {...props} className={variant} />;
}
```

However, that doesn't fix anything, it simply switches the problem around. Now, the variant class will take precedence, and the `className` prop will be ignored.

Getting warmer!

## The solution

The obvious solution is to merge the classes:

```jsx
function Button({ variant, ...props }) {
  return <button {...props} className={`${variant} ${props.className}`} />;
}
```

> Note that this example, as all others throughout this article, is meant as a simplified example.
>
> For instance, in a real-world scenario, you'd probably want to use a library like [clsx](https://www.npmjs.com/package/clsx) to merge classes.

We can go further, and merge other props as well, like event handlers:

```jsx
function Button({ variant, ...props }) {
  return (
    <button
      {...props}
      className={`${variant} ${props.className}`}
      onClick={(event) => {
        props.onClick?.(event); // <-- external handler
        console.log("internal handler");
      }}
    />
  );
}
```

This strategy is great, but we can't merge every prop. In fact, only `className`, `style` and event handlers are usually safe to merge.

The only solution is to let other external props override the internal ones. This is normally okay since the internal props are usually just "defaults", or the user knows what they're doing.

# What is the open/closed pattern?

This approach to handling props is a part of the **open/closed** pattern. Hopefully, the previous example will make it easier to understand.

Here's how Diego defined it:

> The open/closed (...) component:
>
> A component that is based on the open/closed principle, which states that “software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification”.

Let's digest this:

- The component is **closed** for modification, meaning that you can't change the component itself. You can't edit its source code to adapt it to your needs!
- The component is **open** for extension, meaning that you can extend it, **without** changing its implementation.

This is a critical thing to understand. As Diego put it:

> A component is closed for modification when you **don't need** to update its source code to extend its functionality.

So it's not just that you **can't** update the source code, it's that you **don't need** to.

## Sprinkles on top

Native HTML elements are good examples of this. You can't modify how they work directly, but you can extend them to fit your needs by adding attributes and event listeners. When you build a component, you're essentially extending a native element (even on non-web platforms like React Native!).

This pattern is really neat because it allows you to create components that are **also extendable**, on top of native ones. If you're building a custom button and you apply this pattern, you're allowing users to interface both with your custom features (e.g. `variant`) and with the native element ones (e.g. `onClick`).

Even better, you can create other custom components that extend your custom components, creating a "cascade" of extendability.

> If this sounds familiar, that's because it's just good old [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming)! The [open/closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) is an OOP concept.

A way I like to think about this is that you're taking a native element or component, and adding a few sprinkles of functionality (or aesthetics) on top of it.

## Open/closed vs. wrapping

While there's no exact hard distinction between a wrapper component and an open/closed component, I see them as opposites.

In both cases, you're effectively wrapping something else, that much is true.

The key difference is that a wrapper component behaves like a "black box", with a custom API. It might pass down a prop or two, but even then it's not uncommon to see, for example, props called `onSelect` or `action` which are passed down to `onClick` and which exclude the `MouseEvent` argument.

This can make sense sometimes, of course. For example, the `react-aria` library has a [`usePress`](https://react-spectrum.adobe.com/react-aria/usePress.html) utility that wraps all kinds of pointer events (touch, mouse...) and exposes a custom, unified API for them. That can be an immensely useful thing to have.

The way I think about this, though, is that it's probably better to always start with open/closed, and only opt into wrapping when you have really good reasons to do so.

# Building an open/closed component

_"Enough philosophical stuff!"_ you say. _"How do I actually build an open/closed component?"_

Okay, okay. Let's do it (in React).

## Pass the rest props down

We already did this, but let's be more detailed now. We have two types of props:

- Non-mergeable: we want these to be overridable.
- Mergeable: we want to merge these (duh!).

In React, passing props to a component behaves like an object spread (or `Object.assign()`). Since we want any non-mergeable props that we're internally using to be overridable by the user, we need to pass them first. For example:

```jsx {1}
function Button() {
  return <button type="button" />;
}
```

Next, we want to spread the props:

```jsx {1}
function Button(props) {
  return <button type="button" {...props} />;
}
```

This way, `{...props}` will override any previous props.

Finally, we want to merge and pass the mergeable props. We do it after the spread to prevent them from being accidentally overridden. We're already taking care of merging all of the values, so we won't be missing any!

```jsx {5}
function Button({ variant, ...props }) {
  return (
    <button
      type="button"
      {...props}
      className={clsx(variant, props.className)}
    />
  );
}
```

In short, here's the order:

1. Pass non-mergeable props.
2. Spread the rest props.
3. Merge and pass mergeable props.

Let's take a closer look at mergeable props. These are the ones that are usually safe to merge:

### Merging classes

Simple, just concatenate all values separated by spaces. Libraries like [clsx](https://www.npmjs.com/package/clsx) are recommended.

```jsx
const className = clsx(internalClassName, props.className);
```

### Merging styles

In React, styles are objects, so we just need to merge them. We can do so easily with the spread syntax.

```jsx
const style = { ...internalStyle, ...props.style };
```

### Merging event handlers

Event handler props typically start with `on` (e.g. `onClick`), so a common technique is to detect them that way and then create a wrapper function that calls both the internal and external handlers.

The external one must be called first. This is important because that handler could have called `event.preventDefault()`, which is self-explanatory (stops the default behavior of the event).

Our internal handler is the "default behavior" in this case, so we need to check if `preventDefault()` was called (through `event.defaultPrevented`) and, in that case, the internal handler shouldn't run to respect the user's wishes.

The logic is a bit complicated, so it is left as an exercise for the reader. There are a few open-source libraries like [Ariakit](https://ariakit.org/) and [Radix UI](https://www.radix-ui.com/) that do this though, in case you want to see a good example.

## Forward (and merge) refs

In React, we need to forward the ref to the underlying element.
